
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Introduction to F# & Essential tools - My blog</title>
  <meta name="author" content="Bilal Durrani">

  
  <meta name="description" content="Introduction to F# & Essential Tools next | previous | Main Introduction In this chapter, we introduce the F# language and learn how to get our &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://bdurrani.github.com/fsurvival/introtof/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="My blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   class="no-sidebar"  >
  <header role="banner"><hgroup>
  <h1><a href="/">My blog</a></h1>
  
    <h2>My attempts</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:bdurrani.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
<li><a href="/">Blog</a></li>
<!--  
      <li><a href="/blog/archives">Archives</a></li>
-->
   <li> <a href="/fsurvival/preface">F# Survival Guide</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article role="article">
  
  <header>
    <h1 class="entry-title">Introduction to F# & Essential Tools</h1>
    
  </header>
  
  <link href='/stylesheets/fsurvival.css' rel='stylesheet' type='text/css' /><ul style='list-style:none'>
<li class='right'>
<a href='\fsurvival\next'>next</a>
</li>
<li style='float: right'>
 | 
</li>
    <li class='right'>
<a href='\fsurvival\whatisfunctional'>previous</a>
    </li>
    <li style='float:right'>
    |
    </li>
    <li class='right'>
    <a href='\fsurvival\toc'>Main</a>    
    </li>
</ul>
<h2 id='introduction'>Introduction</h2>

<p>In this chapter, we introduce the F# language and learn how to get our first program up and running. In doing so, we will discuss the basic rules around F# program structure and the essential tools you will need to develop rudimentary applications. As we progress through the book, and our experience grows, we will delve more deeply into code examples, tool examples, etc.</p>

<h2 id='overview_of_f'>Overview of F</h2>

<p>F# is a strongly typed, first-class .NET programming language designed by <a href='http://research.microsoft.com/en-us/people/dsyme/'>Don Syme</a> and others at <a href='http://research.microsoft.com/en-us/'>Microsoft Research</a>. It has its origins in the <a href='http://en.wikipedia.org/wiki/ML_programming_language'>ML approach to language design</a> and is a close relative of <a href='http://en.wikipedia.org/wiki/OCaml'>OCaml</a>.</p>

<p>While billed primarily as a functional language, F# is in actuality a multi-paradigm language. This means that it supports imperative, OO, and functional styles of programming. A fully supported .NET language in its own right, F# interoperates naturally with code written in other .NET languages such as C# and VB.NET.</p>

<p>F# is available as part of Microsoft Visual Studio 2010 and the Mono project. You can also use it with Visual Studio 2008, although that requires a separate download. It is also available as a <a href='http://msdn.microsoft.com/en-us/vstudio/hh388569.aspx'>seperate download</a>. You can find the most recent F# Language Reference <a href='http://msdn.microsoft.com/en-us/library/dd233181'>here</a>. For this book, all the code was tested with build 4.0.40219.1 in Visual Studio 2010.</p>

<p>Please consult the language reference for the basic rules and regulations of F#, e.g. the rules around defining a valid symbolic name, etc.</p>

<h2 id='f_program_structure'>F# Program Structure</h2>

<p>You create F# programs using a standard text editor or IDE. With an IDE such as Visual Studio 2010, you get the benefit of syntax highlighting, Intellisense, etc. As with other programming languages, F# adheres to a specific set of syntax and structural rules, uses a well-defined set of keywords, etc. We will cover the core keywords, syntax, and structure of F# programs starting in this chapter, and will continue to build on this knowledge throughout the rest of the text.</p>

<h3 id='id1'><code>#light</code></h3>

<p>Due to its heritage, F# is compatible with OCaml. This means that you can write F# programs that are fully compliant with OCaml&#8217;s syntax and semantic rules. Many developers, however, find OCaml&#8217;s syntax to be quite <em>chatty</em>; therefore, F# supports a more streamlined programming syntax and semantic, known as <strong>light</strong> mode. You instruct F# to adhere to this light mode by placing the #light directive at the top of each of your F# program files.</p>

<p>For all intents and purposes, all of the F# programs that you encounter and write will use the <code>#light</code> directive. If you fail to use place the <code>#light</code> directive at the top of each of your F# program files, you will default to OCaml-compatible <em>verbose mode.</em> This will require the use of particular keywords and symbols to terminate expressions, etc.<br />In the spirit of keeping things streamlined and to the point, we will not cover the verbose mode syntax in this book, nor will we cover structures and/or symbols that are in F# solely to support OCaml compatibility.</p>

<h3 id='whitespace_matters'>Whitespace Matters</h3>

<p>When you write F# programs and use the #light<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup> directive, whitespace becomes significant to the structure and execution of the program. Whereas other languages, e.g. C#, use braces or other symbols to group compound statements, F# uses whitespace indentation for the same purpose<sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup>.</p>

<p>Code that is vertically aligned by whitespace indentation is considered to be semantically related. Python programmers will feel right at home with this concept. Note that F# does not recognize TAB as a valid whitespace character when used for aligning code blocks in #light mode. This means that you need to use spaces to align your code. Before you groan too loudly, read the next two points:</p>

<ol>
<li>The number of spaces doesn&#8217;t seem to matter. You can use 1 or more. I typically use 4, which matches the equivalent TAB.</li>

<li>When working in a Visual Studio F# Project (more on this shortly), the IDE converts TAB to spaces automatically. So, you can use the TAB key to align your code, and Visual Studio does the right thing in terms of ensuring your F# files have the right kind of whitespace.<br />I assume you can set up your editor of choice to replace TABs with spaces as well.</li>
</ol>

<h3 id='comments'>Comments</h3>

<p>F# provides several different types of comment structures: single line comments, multiline comments and document (doc) comments. Let&#8217;s take a look at each type below.</p>

<h4 id='single_line_comments'>Single Line Comments</h4>

<p>Single line comments begin with a //. Everything following the // is considered to be a comment. The comment extends to the end of the source code line.</p>
<figure class='code'><div class='highlight'><table><tr><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// This is a single-comment. Everything from the start is treated as a comment.</span></code></pre></td></tr></table></div></figure>
<h4 id='multiline_comments'>Multiline Comments</h4>

<p>Multiline comments begin with (* and end with *).</p>
<figure class='code'><div class='highlight'><table><tr><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(* This is a multiline comment with only one line *)
</span><span class='line'>(* This is another
</span><span class='line'>multiline comment *)</span></code></pre></td></tr></table></div></figure>
<h4 id='document_doc_comments'>Document (Doc) Comments</h4>

<p>Doc comments start with &#8216;///&#8217; and are used to embed comments in the code from which XML or HTML documentation can be produced automatically. These comments are normally placed before the definitions of functions, data types, classes, discriminated unions, etc. We will discuss each of these structures in depth in future chapters.</p>
<figure class='code'><div class='highlight'><table><tr><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/// This is a doc comment that can be converted to useful documentation.</span></code></pre></td></tr></table></div></figure>
<h3 id='keywords'>Keywords</h3>

<p>F# has a small set of reserved keywords. These <a href='http://msdn.microsoft.com/en-us/library/dd233249.aspx'>keywords</a> cannot be used as value or identifier names, as they have special meaning to the compiler:</p>

<p>Don&#8217;t worry that you may not understand most (or any!) of these keywords at this point. We will explore each of them throughout the course of this book. For each keyword, we will discuss its use in F# and how it applies to functional programming in general.</p>

<h2 id='statements_vs_expressions'>Statements vs. Expressions</h2>

<p>In many programming languages, there is a sharp distinction drawn between statements and expressions. It is an important distinction, since it dictates where you can use given programming structures, and how these structures are ultimately evaluated. Let&#8217;s come up with working definitions that we can rely on throughout the text.</p>

<h3 id='statements'>Statements</h3>

<p>Statements are lines of code that impart a directive &#8211; they <em>do</em> something. Statements do not evaluate to a value, and cannot be passed into functions as parameters.</p>

<p>F# has no statements.</p>

<h3 id='expressions'>Expressions</h3>

<p>Expressions are lines of code that evaluate to a value, e.g.:</p>
<figure class='code'> <div class='highlight'><table><tr><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class='k'>let</span> <span class='n'>x</span> <span class='o'>=</span> <span class='mi'>100</span>
</span><span class='line'><span class='n'>x</span>
</span></code></pre></td></tr></table></div></figure>
<p><strong>In F#, every program construct is an expression.</strong></p>

<p>This means that all program constructs evaluate to a value of a concrete data type.</p>

<p>The fact that all constructs in F# are expressions is important, because it influences the way we write our programs. If you do not understand the difference between statements and expressions, re-read this small section until you are comfortable with the difference. The take-away here is that F# has no statements, only expressions.</p>

<p>Note that one oddball case that comes up in the statement/expression scheme of things concerns <code>let</code>. By itself, let does not always evaluate to an expression, e.g., it cannot be used as the last line of a function. In these cases, you must supply the <code>let</code>&#8217;s symbol, e.g., x in the example above.</p>

<h3 id='accessing_existing_net_types'>Accessing Existing .NET Types</h3>

<p>In some of the examples in this book, and certainly in real-world programs, you will need to access functionality present in external libraries and modules. To gain access to the functionality contained in these libraries and modules, we use the F# keyword <code>open</code>.</p>

<h4 id='open'>open</h4>

<p>The <code>open</code> keyword (like the C# using statement), brings an existing namespace into scope. This affords us the convenience of using the namespace&#8217;s interfaces, classes, etc. without having to fully qualify the names each and every time. The <code>open</code> statement is called an <em>import</em> statement, and takes the following form:</p>

<p><code>open module-or-namespace</code><sup id='fnref:3'><a href='#fn:3' rel='footnote'>3</a></sup></p>

<p>Here, namespace must be a valid .NET namespace &#8211; either a built-in namespace or one of your creation (or third-party creation). Note that to gain access to a given namespace, you must have a reference to the proper .NET type-container such as a DLL, e.g., System.Windows.Forms.dll. If the IDE reports that it cannot resolve an open expression, make sure you have a reference to the DLL containing the namespace you&#8217;re trying to open.</p>

<p>Let&#8217;s look at an example. To gain access to the classes in the .NET System namespace, we can either fully qualify the name, e.g., System.Environment, or we can open the System namespace and use the Environment class without qualification. The following example demonstrates the difference:</p>
<figure class='code'><figcaption><span>Without using open </span></figcaption>
 <div class='highlight'><table><tr><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class='k'>let</span> <span class='n'>fpath</span> <span class='o'>=</span> <span class='nn'>System</span><span class='p'>.</span><span class='nn'>Environment</span><span class='p'>.</span><span class='nc'>GetFolderPath</span><span class='o'>(</span><span class='nn'>System</span><span class='p'>.</span><span class='nn'>Environment</span><span class='p'>.</span><span class='nn'>SpecialFolder</span><span class='p'>.</span><span class='nc'>Desktop</span><span class='o'>)</span>
</span></code></pre></td></tr></table></div></figure><figure class='code'><figcaption><span>With using open </span></figcaption>
 <div class='highlight'><table><tr><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class='k'>open</span> <span class='nc'>System</span>
</span><span class='line'><span class='k'>let</span> <span class='n'>fpath2</span> <span class='o'>=</span> <span class='nn'>Environment</span><span class='p'>.</span><span class='nc'>GetFolderPath</span><span class='o'>(</span><span class='nn'>Environment</span><span class='p'>.</span><span class='nn'>SpecialFolder</span><span class='p'>.</span><span class='nc'>Desktop</span><span class='o'>)</span>
</span></code></pre></td></tr></table></div></figure>
<p>Via <code>open System</code>, we get access to System&#8217;s publicly available types, classes, interfaces, etc. without needing to fully qualify their names.</p>

<p>The open declaration makes the names available in the code that follows the declaration, up to the end of the enclosing namespace, module, or file. When you use multiple import declarations, they should appear on separate lines. There is no special line-termination character.</p>

<h3 id='dealing_with_ambiguity'>Dealing with Ambiguity</h3>

<p>There are times when you open multiple namespaces, and the same name (function, type, etc.) appears in more than one of them. Unfortunately, the F# compiler does not emit an error or warning when ambiguities or name clashes occur. Instead, F# uses a <em>last one wins</em> strategy, giving preference to the more recently opened module or namespace. As of this writing, the MSDN documentation suggests <em>being careful</em> when using namespaces that could export colliding names. If you do open namespaces that create ambiguity, you can explicitly specify the construct you want by spelling out the entire, qualified name. When in doubt, be verbose!</p>

<h3 id='namespaces_open_by_default'>Namespaces Open by Default</h3>

<p>There are certain namespaces that are so common that F# makes them available automatically. These are as follows:</p>

<p><strong>Microsoft.FSharp.Core</strong>: Contains basic F# type definitions for built-in types such as int and double.</p>

<p><strong>Microsoft.FSharp.Core.Operators</strong>: Contains core arithmetic operations such as + for addition and * for multiplication.</p>

<p><strong>Microsoft.FSharp.Collections</strong>:Contains immutable collection classes such as List and Array.</p>

<p><strong>Microsoft.FSharp.Control</strong>:Contains types for control constructs such as lazy evaluation and asynchronous workflows (covered later).</p>

<p><strong>Microsoft.FSharp.Text</strong>:Contains functions for formatted IO, such as the <code>printfn</code> function.</p>

<p>Your F# programs can use the publicly available constructs from these default libraries without using an open statement and without fully qualifying their names.</p>

<h3 id='tools_of_the_trade'>Tools of the Trade</h3>

<h4 id='f_interactive_console'>F# Interactive (Console)</h4>

<p>F# ships with an interactive, command-line style interactive programming window called the F# Interactive Console. The console executable, fsi.exe, lives under the F# installation bin directory. On my machine, the full path to the console is:</p>

<p>C:\Program Files (x86)\Microsoft F#\v4.0\fsi.exe</p>

<p>This console enables you to enter and execute F# expressions, and receive feedback. The F# Interactive Console runs stand-alone; therefore, you do not need to have Visual Studio running to launch it.</p>

<p>Using the F# Interactive Console is a great way to explore the F# language, interactively test blocks of code, incrementally prototype algorithms, etc.<br />You can, and I suggest you should, use the F# Interactive Console to run and test all of the examples in this book.</p>

<p>To ensure your F# environment is set up correctly, launch the command prompt and change the directory to the path where the fsi.exe lives. The console should look like the following:</p>
<img class='center' src='/images/fsurvival/consolestart.PNG' />
<p>This is the F# Interactive Console Window. The normal prompt is a greater than symbol (&gt;), which indicates that F# is ready to accept a new expression. Let&#8217;s use a simple example to see how this works.</p>

<p>Any programming book worth its salt includes a &#8220;hello, world!&#8221; program, so in the venerable tradition of Kernighan and Ritchie (K&amp;R), let&#8217;s make sure F# is installed correctly by entering in the following line of F# code in the F# Interactive Console:</p>
<figure class='code'> <div class='highlight'><table><tr><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class='n'>printfn</span> <span class='s2'>&quot;hello, world!&quot;</span><span class='o'>;;</span>
</span></code></pre></td></tr></table></div></figure>
<p>Note that you terminate expressions in the F# Interactive Console using a pair of semicolons (;;). F# will respond by printing the line of text, and by providing some feedback, as shown in the following:</p>
<figure class='code'><figcaption><span>Result from interactive console</span></figcaption>
<div class='highlight'><table><tr><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>> printfn "hello, world!";;
</span><span class='line'>hello world
</span><span class='line'>val it : unit = ()
</span><span class='line'>></span></code></pre></td></tr></table></div></figure>
<p>Don&#8217;t worry too much about the feedback. Here F# is telling us that the expression it just evaluated (the <em>it</em>) returned F#&#8217;s equivalent of void (unit, also expressed as ()). We&#8217;ll cover these concepts shortly.</p>

<p>Note that F# is a case-sensitive language, i.e., case is significant. You cannot, for example, enter <code>PRINTFN &quot;hello, world!&quot;</code>;;. F# will produce an error letting you know that PRINTFN is not a recognized command or function:</p>

<p><code>error FS0039: The value or constructor &#39;Printfn&#39; is not defined.</code></p>

<p>While using the F# Interactive Console, it&#8217;s easy to forget to terminate your expressions using ;;.If you forget to do this, here is what you&#8217;ll see:</p>
<figure class='code'><figcaption><span>Not terminating the expressions </span></figcaption>
<div class='highlight'><table><tr><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>> printfn "hello, world!"
</span><span class='line'>-</span></code></pre></td></tr></table></div></figure>
<p>Notice the F# responded by outputting a dash (-), indicating that it&#8217;s waiting for more input. At this point, you can enter another F# expression, or terminate the current expression using ;;. If you enter another expression, F# adds this to the current &#8220;expression set&#8221;. It continues to add expressions to its expression set until you terminate the set using ;;, at which point it will execute all the expression in the set at once. In the following, we entered 2 expressions for F# to evaluate.</p>
<figure class='code'><figcaption><span>Multiple expressions </span></figcaption>
<div class='highlight'><table><tr><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>> printfn "hello world"
</span><span class='line'>- printfn "it's me";;
</span><span class='line'>hello world
</span><span class='line'>it's me
</span><span class='line'>></span></code></pre></td></tr></table></div></figure>
<p>The F# Interactive Console has a handful of directives that it understands. For a list of these directives, enter <code>#help;;</code> at the command prompt (&gt;), as shown below:</p>
<figure class='code'><figcaption><span>Help directive </span></figcaption>
<div class='highlight'><table><tr><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>#help;;
</span><span class='line'>
</span><span class='line'>F# Interactive directives:
</span><span class='line'>
</span><span class='line'>   #r "file.dll";;        Reference (dynamically load) the given DLL
</span><span class='line'>   #I "path";;            Add the given search path for referenced DLLs
</span><span class='line'>   #load "file.fs" ...;;  Load the given file(s) as if compiled and referenced
</span><span class='line'>   #time ["on"|"off""];;  Toggle timing on/off
</span><span class='line'>   #help;;                Display help
</span><span class='line'>   #quit;;                Exit
</span><span class='line'>
</span><span class='line'> F# Interactive command line options:
</span><span class='line'>
</span><span class='line'>     See 'fsi --help' for options
</span><span class='line'>></span></code></pre></td></tr></table></div></figure>
<p>The first three entries are used to access pre-existing libraries and assemblies. For example, if you want to access .NET libraries that provide Web access, you need to access the System.Web.dll. This DLL is not available by default; therefore, to gain access to it in the F# Interactive Console, you would enter the following command:</p>
<figure class='code'><div class='highlight'><table><tr><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#r "System.Web.dll";;</span></code></pre></td></tr></table></div></figure>
<p>Note that the double quotes surrounding the library name are necessary for this command to work properly, as shown in the following:</p>
<figure class='code'><figcaption><span>Missing double-quotes when referencing a library name</span></figcaption>
<div class='highlight'><table><tr><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>> #r System.Web.dll;;
</span><span class='line'>
</span><span class='line'>  #r System.Web.dll;;
</span><span class='line'>  ---^^^^^^
</span><span class='line'>
</span><span class='line'>stdin(6,4): error FS0010: Unexpected identifier in interaction. 
</span><span class='line'>Expected incomplete structured construct at or before this point, ';', ';;' or other token.
</span><span class='line'>></span></code></pre></td></tr></table></div></figure>
<p>At the moment, there&#8217;s nothing useful we can do with this library, since we don&#8217;t have enough F# syntax as context. I just wanted you to get a feel for what these command do. We&#8217;ll see how to leverage the .NET class libraries in gory detail in Chapter 13.</p>

<p>We use the <code>#path</code> command to extend the search path that F# uses in order to find libraries and assemblies, and the #load command to load an F# file into memory, compile it, and make it available for use.</p>

<p>We can use the <code>#time</code> command to activate basic profiling for F# expressions, measuring their execution times. For example, Issue the <code>#time &quot;on&quot;</code> command to activate profiling, and <code>#time &quot;off&quot;</code> to deactivate it. We use both in the following example:</p>
<figure class='code'><div class='highlight'><table><tr><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>> #time "on";;
</span><span class='line'>
</span><span class='line'>--> Timing now on
</span><span class='line'>
</span><span class='line'>> printfn "hello world";;
</span><span class='line'>hello world
</span><span class='line'>Real: 00:00:00.002, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0
</span><span class='line'>val it : unit = ()
</span><span class='line'>> #time "off";;
</span><span class='line'>
</span><span class='line'>--> Timing now off
</span><span class='line'>
</span><span class='line'>></span></code></pre></td></tr></table></div></figure>
<p>As you can see from the output, activating timing causes the F# Interactive Console to output CPU time and generation-centric garbage collection information.</p>

<p>At the time of this writing, there is no way to use the F# Interactive Console to get help on a keyword or built-in function.</p>

<p>If you want to influence how the F# Interactive Console behaves, you can launch it yourself and provide command-line switches. For example, if you want to launch the console so that standard output is suppressed, provide the -quiet switch.</p>

<p>For a full list of all the switches available, enter <em>fsi -help</em> on the standard command line.</p>

<p>Unfortunately, once the F# Interactive Console is up and running, there doesn&#8217;t seem to be a way to reset its environment to eliminate all bound references, etc. When I need to do this, I generally close my current session and start anew.</p>

<p>When you enter something the F# does not understand completely, it will display an error message in red text, as shown below:</p>
<img class='center' src='/images/fsurvival/consoleerror.PNG' />
<p>You will receive error output even if you are running in quiet mode; however, that is the extent of the console&#8217;s debugging capabilities. The F# Interactive Console does not have a provision for debugging F# code snippets. To debug scripts or programs, you need to use the full Visual Studio IDE and debugger.</p>

<p>Once you&#8217;re done using the F# Interactive Console, you can exit by closing the console window or by executing the <code>#quit;;</code> command.</p>

<h3 id='f_interactive_console_and_visual_studio'>F# Interactive Console and Visual Studio</h3>

<p>F# is already included as part of Visual Studio 2010. If you have Visual Studio 2008 installed, you will need to install F# separetly. Once you have F#, it will integrate with Visual Studio by adding a set of project templates and a handful of new menu items. These changes enable you to create F# solutions and projects, and to use the Visual Studio IDE and the F# Interactive Console in unison. To display the F# Interactive Console in Visual Studio 2008 or higher, go the main menu and select View -&gt; Other Windows -&gt; F# Interactive. One convenient feature the integrated console window supports is the ability for you to reset its environment: right-click your mouse over the window and select Reset Session from the context menu.</p>

<p>The best and easiest way to work with the integrated console is to develop code in the IDE editor, select it, and then right-click the mouse over the selection to bring up the editor&#8217;s context menu. If you select the menu item Send to Interactive, Visual Studio will send the selected code to the integrated F# Interactive Console, and will automatically append a ;; to the end of the entire block, which you use to terminate a set of statements in the console window. In response, the console will execute the F# code and provide immediate feedback.</p>

<p>Note that when working in the F# Interactive Console directly (vs. working in the IDE and using Send to Interactive), you must explicitly terminate each logical expression with ;; (two semicolons). A logical expression can span more than one line. This means that you can have several F# sources lines terminated by a single ;; pair. Throughout this text, we will see examples of single-line and multi-line expressions used in the F# Interactive Console. When working outside of the F# Interactive Console, a normal newline character terminates F# expressions implicitly &#8211; you do not need to use ;;, e.g.,. when you&#8217;re building an F# application in the IDE and build it to produce a DLL or EXE.</p>

<p>As you start using the F# Interactive Console, you will notice that for each expression/program you enter, F# will provide feedback. This feedback will consist of all expression/program output plus F#&#8217;s evaluation of the data types involved. I found (and still sometimes find) F#&#8217;s typing signatures a little confusing to decipher, so I will spend some time explaining what the type signatures mean as we encounter them.</p>

<h3 id='f_projects_in_visual_studio'>F# Projects in Visual Studio</h3>

<p>After installing F#, you will find that Visual Studio offers a new set of project templates. This is what the New Project window looks like on my machine:</p>
<img class='center' src='/images/fsurvival/newproject.PNG' />
<p>Visual Studio offers the following project types:</p>

<ul>
<li>
<p>F# Application. Select this type of project to create a command-line (console) application (EXE).</p>
</li>

<li>
<p>F# Library. Select this type of project to create an F# library. A library is a DLL that can be included in other .NET projects. When you select this project type, the resulting solution will contains two files:</p>

<ul>
<li>Module1.fs. This is the default source file for the library that will be compiled into the output DLL.</li>

<li>Script.fsx. This is a script file that you can use to work with F# interactively. The code that you enter into this file is not included in the final output DLL.</li>
</ul>
</li>

<li>
<p>F# Tutorial. Select this type of project to create an F# source file that illustrates key features of the F# language. This project creates an EXE.</p>
</li>
</ul>

<p>We will wait until the chapter on functions (Chapter 8) to provide full IDE-based examples, since at this point you will be prepared to write full, simple F# programs.</p>

<h3 id='the_f_compiler'>The F# Compiler</h3>

<p>When you use Visual Studio to build an F# application, it executes the underlying F# compiler, fsc.exe.</p>

<p>Like any other .NET compiler, the F# compiler supports a variety of configuration options. For more information about the F# compiler and its options, please see the <a href='http://msdn.microsoft.com/en-us/library/dd233171.aspx'>F# compiler documentation on MSDN</a>.</p>

<h3 id='printing_values_using_printf'>Printing Values using Printf</h3>

<p>As you work through examples in this book and on the wild Web, you will be displaying values to the F# console a good deal of the time. Be advised that F# ships with a <a href='http://msdn.microsoft.com/en-us/library/ee370560'>module called Printf</a> that enables you to display values in a variety of formats.<br />For those of you coming from a C# or VB.NET background, check out <a href='http://msdn.microsoft.com/en-us/library/ee370560'>Printf.sprint and Printf.kprintf</a>.</p>

<p>What You Need to Know</p>

<ul>
<li>F# is a multi-paradigm language whose main thrust is to support functional programming constructs.</li>

<li>F# is a fully supported .NET language capable of interoperating with other .NET languages.</li>

<li>F# is based on a language called OCaml. You can use OCaml syntax to write F# programs; however, OCaml&#8217;s syntax is verbose. F# supports a less verbose <em>light</em> syntax that most developers favor. To ensure you are using the light version, you must place the <code>#light</code> directive at the very top of each of your F# source code files. We use the light syntax in this book.</li>

<li>The primary syntactical construct in F# is an expression, i.e., something that evaluates to a value. F# does not have statements, per se.</li>

<li>You can use the F# Interactive Console (fsi.exe) to explore F#. We recommend you use the console to experiment with simple expressions while learning the F# language.</li>

<li>The F# Interactive Console can be run stand-alone, integrated with Visual Studio 2008/2010, or both.</li>

<li>F#&#8217;s compiler is called fsc.exe. Similar to compilers for most other languages, it has a variety of options that you can use to control how it operates.</li>

<li>Using Visual Studio, you can create console applications, libraries (DLLs) and applications (EXEs) with F#, just like you would do with other .NET languages.<br />You can even link and execute modules compiled from F# seamlessly with modules written in other .NET languages.</li>
</ul>
<ul style='list-style:none'>
<li class='right'>
<a href='\fsurvival\next'>next</a>
</li>
<li style='float: right'>
 | 
</li>
    <li class='right'>
<a href='\fsurvival\whatisfunctional'>previous</a>
    </li>
    <li style='float:right'>
    |
    </li>
    <li class='right'>
    <a href='\fsurvival\toc'>Main</a>    
    </li>
</ul><div class='footnotes'><hr /><ol><li id='fn:1'>
<p>If you are not using the <code>#light</code> directive, you are defaulting to using full OCaml syntax, which obviates the need for significant whitespace, but imposes the burden of semantically significant keywords.</p>
<a href='#fnref:1' rev='footnote'>&#8617;</a></li><li id='fn:2'>
<p>Python programmers will feel at home here.</p>
<a href='#fnref:2' rev='footnote'>&#8617;</a></li><li id='fn:3'>
<p>In F#, a module is a way to package code. It is a grouping of F# code, such as values, types, and function values. Grouping code in modules helps keep related code together and helps avoid name conflicts in your program. We will cover modules later.</p>
<a href='#fnref:3' rev='footnote'>&#8617;</a></li></ol></div>
  
</article>

</div>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Bilal Durrani -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
